/**
 * Games API - Mutation Hooks (Data Modification)
 *
 * This file contains all TanStack Query hooks for MODIFYING game data:
 * - Creating games
 * - Updating games
 * - Deleting games
 * - RSVPing to games
 *
 * Current Status: USING MOCK DATA
 * - All mutations simulate database operations
 * - No actual data is persisted (resets on app restart)
 * - When Supabase is ready, uncomment the real mutations (marked with TODO)
 *
 * Architecture Flow (Mutations):
 * 1. Component calls mutation: createGame.mutate(gameData)
 * 2. TanStack Query calls mutationFn
 * 3. mutationFn simulates database operation (will be Supabase later)
 * 4. onSuccess callback runs (invalidates cache, updates UI)
 * 5. Component automatically re-renders with updated data
 *
 * Key Concepts:
 * - mutationFn: Function that modifies data
 * - onSuccess: Runs after successful mutation (update cache)
 * - onError: Runs if mutation fails (show error message)
 * - optimistic updates: Update UI before server responds
 *
 * Cache Invalidation:
 * - After creating/updating/deleting, we "invalidate" related queries
 * - This tells TanStack Query to refetch that data
 * - Example: Create game â†’ invalidate ['games'] â†’ games list refreshes
 *
 * @see https://tanstack.com/query/latest/docs/react/guides/mutations
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../client';
import { Game } from '../../types';

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * Input type for creating a new game
 * Subset of Game - excludes fields auto-generated by database
 */
export interface CreateGameInput {
  title: string;
  sport: string;
  game_type: 'pickup' | 'league' | 'tournament' | 'exhibition';
  start_time: string;
  end_time?: string;
  location_name: string;
  location_address: string;
  coordinates?: { lat: number; lng: number };
  max_participants?: number;
  entry_fee_cents?: number;
  description?: string;
  rules?: string;
  privacy?: 'public' | 'private' | 'friends_only';
}

/**
 * Input type for updating a game
 * All fields optional (partial update)
 */
export interface UpdateGameInput {
  title?: string;
  start_time?: string;
  end_time?: string;
  location_name?: string;
  location_address?: string;
  max_participants?: number;
  entry_fee_cents?: number;
  description?: string;
  rules?: string;
  status?: 'open' | 'in_progress' | 'completed' | 'cancelled';
}

/**
 * Input type for RSVP
 */
export interface CreateRSVPInput {
  game_id: string;
  status: 'attending' | 'maybe' | 'declined';
}

// ============================================================================
// MUTATION HOOKS
// ============================================================================

/**
 * Create a new game
 *
 * Features:
 * - Auto-invalidates games list (triggers refetch)
 * - Returns created game with generated ID
 * - Shows loading/error states
 * - Can use optimistic updates (update UI before server responds)
 *
 * Usage Example:
 *   ```tsx
 *   const CreateGameForm = () => {
 *     const createGame = useCreateGame();
 *
 *     const handleSubmit = async (formData) => {
 *       try {
 *         const newGame = await createGame.mutateAsync(formData);
 *         Alert.alert('Success', 'Game created!');
 *         router.push(`/game/${newGame.id}`);
 *       } catch (error) {
 *         Alert.alert('Error', error.message);
 *       }
 *     };
 *
 *     return (
 *       <Form onSubmit={handleSubmit}>
 *         <Button
 *           onPress={handleSubmit}
 *           loading={createGame.isPending}
 *         >
 *           Create Game
 *         </Button>
 *       </Form>
 *     );
 *   };
 *   ```
 *
 * What happens:
 * 1. User submits form
 * 2. isPending = true (button shows loading)
 * 3. Mutation runs (creates game in database)
 * 4. onSuccess runs (invalidates ['games'] cache)
 * 5. Games list automatically refetches and shows new game
 * 6. isPending = false (button returns to normal)
 *
 * @returns TanStack mutation hook
 */
export const useCreateGame = () => {
  // Get query client to invalidate caches
  const queryClient = useQueryClient();

  return useMutation({
    // Mutation function: Creates the game
    mutationFn: async (gameData: CreateGameInput) => {
      // ===================================================================
      // MOCK DATA MODE (Current)
      // ===================================================================

      // Simulate network delay
      await new Promise(resolve => setTimeout(resolve, 800));

      // Simulate database inserting and returning the game
      const newGame: Game = {
        ...gameData,
        id: `game_${Date.now()}`, // Mock ID generation
        status: 'open',
        current_participants: 0,
        host_user_id: 'current_user_id', // TODO: Get from auth
        host_team_id: null,
        game_metadata: {},
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      console.log('âœ… Game created (mock):', newGame.id);
      return newGame;

      // ===================================================================
      // REAL SUPABASE MODE (Future - uncomment when ready)
      // ===================================================================

      /*
      // Get current user ID from auth
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Insert game into database
      const { data, error } = await supabase
        .from('games')
        .insert({
          ...gameData,
          host_user_id: user.id,
          status: 'open',
          current_participants: 0,
        })
        .select()
        .single();

      if (error) {
        console.error('âŒ Error creating game:', error);
        throw error;
      }

      console.log('âœ… Game created:', data.id);
      return data;
      */
    },

    // Success callback: Runs after mutation succeeds
    onSuccess: (newGame) => {
      console.log('ðŸ”„ Invalidating games cache...');

      // Invalidate all games queries
      // This tells TanStack Query: "games data is now stale, refetch it"
      queryClient.invalidateQueries({ queryKey: ['games'] });

      // Optional: Optimistically update cache without refetching
      // This makes the UI update instantly
      /*
      queryClient.setQueryData(['games'], (oldGames: Game[] = []) => {
        return [...oldGames, newGame];
      });
      */

      console.log('âœ… Games cache invalidated, will refetch automatically');
    },

    // Error callback: Runs if mutation fails
    onError: (error: any) => {
      console.error('âŒ Failed to create game:', error);
      // Could show toast notification here
    },
  });
};

/**
 * Update an existing game
 *
 * Features:
 * - Only updates provided fields (partial update)
 * - Invalidates both games list and single game cache
 * - UX Check: Shows button only if user owns the game
 *
 * UX vs Security Note:
 * - The frontend check (isOwner) is for UX only - shows/hides button
 * - Real security is in Supabase RLS (Row Level Security)
 * - Even if user bypasses the UI check, RLS will block the update
 * - This is intentional - frontend can't be trusted for security
 *
 * Usage Example:
 *   ```tsx
 *   const GameEditForm = ({ game, userId }) => {
 *     const updateGame = useUpdateGame();
 *
 *     // UX check (not security) - only show edit button to owner
 *     const isOwner = game.host_user_id === userId;
 *
 *     if (!isOwner) {
 *       return <Text>Only the host can edit this game</Text>;
 *     }
 *
 *     const handleUpdate = async (updates) => {
 *       await updateGame.mutateAsync({
 *         gameId: game.id,
 *         updates
 *       });
 *     };
 *
 *     return <Form onSubmit={handleUpdate} />;
 *   };
 *   ```
 *
 * @returns TanStack mutation hook
 */
export const useUpdateGame = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ gameId, updates }: { gameId: string; updates: UpdateGameInput }) => {
      // ===================================================================
      // MOCK DATA MODE (Current)
      // ===================================================================

      await new Promise(resolve => setTimeout(resolve, 600));

      // In mock mode, we can't actually update data
      // Just return a mock updated game
      const updatedGame: Game = {
        id: gameId,
        ...updates as any, // Merge updates
        updated_at: new Date().toISOString(),
      } as Game;

      console.log('âœ… Game updated (mock):', gameId);
      return updatedGame;

      // ===================================================================
      // REAL SUPABASE MODE (Future - uncomment when ready)
      // ===================================================================

      /*
      // Update game in database
      // RLS policy ensures only the host can update
      const { data, error } = await supabase
        .from('games')
        .update(updates)
        .eq('id', gameId)
        .select()
        .single();

      if (error) {
        // RLS will return permission error if user isn't the host
        if (error.code === 'PGRST301') {
          throw new Error('You can only update games you created');
        }
        throw error;
      }

      console.log('âœ… Game updated:', gameId);
      return data;
      */
    },

    onSuccess: (updatedGame) => {
      // Invalidate both the games list and this specific game
      queryClient.invalidateQueries({ queryKey: ['games'] });
      queryClient.invalidateQueries({ queryKey: ['game', updatedGame.id] });
      console.log('âœ… Cache invalidated for updated game');
    },

    onError: (error: any) => {
      console.error('âŒ Failed to update game:', error);
    },
  });
};

/**
 * Delete a game
 *
 * Features:
 * - Removes game from database
 * - Invalidates caches
 * - UX Check: Only show delete button to owner
 * - Real Security: Supabase RLS prevents non-owners from deleting
 *
 * Usage Example:
 *   ```tsx
 *   const GameActions = ({ game, userId }) => {
 *     const deleteGame = useDeleteGame();
 *
 *     // UX check - show delete button only to owner
 *     const isOwner = game.host_user_id === userId;
 *
 *     const handleDelete = async () => {
 *       Alert.alert(
 *         'Delete Game',
 *         'Are you sure?',
 *         [
 *           { text: 'Cancel', style: 'cancel' },
 *           {
 *             text: 'Delete',
 *             style: 'destructive',
 *             onPress: async () => {
 *               await deleteGame.mutateAsync(game.id);
 *               router.back();
 *             }
 *           }
 *         ]
 *       );
 *     };
 *
 *     if (!isOwner) return null;
 *
 *     return (
 *       <Button
 *         onPress={handleDelete}
 *         loading={deleteGame.isPending}
 *         variant="destructive"
 *       >
 *         Delete Game
 *       </Button>
 *     );
 *   };
 *   ```
 *
 * @returns TanStack mutation hook
 */
export const useDeleteGame = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (gameId: string) => {
      // ===================================================================
      // MOCK DATA MODE (Current)
      // ===================================================================

      await new Promise(resolve => setTimeout(resolve, 600));
      console.log('âœ… Game deleted (mock):', gameId);

      // ===================================================================
      // REAL SUPABASE MODE (Future - uncomment when ready)
      // ===================================================================

      /*
      const { error } = await supabase
        .from('games')
        .delete()
        .eq('id', gameId);

      if (error) {
        if (error.code === 'PGRST301') {
          throw new Error('You can only delete games you created');
        }
        throw error;
      }

      console.log('âœ… Game deleted:', gameId);
      */
    },

    onSuccess: (_, gameId) => {
      // Invalidate games list
      queryClient.invalidateQueries({ queryKey: ['games'] });

      // Remove this specific game from cache
      queryClient.removeQueries({ queryKey: ['game', gameId] });

      console.log('âœ… Cache cleared for deleted game');
    },

    onError: (error: any) => {
      console.error('âŒ Failed to delete game:', error);
    },
  });
};

/**
 * RSVP to a game
 *
 * Features:
 * - Creates or updates RSVP
 * - Increments participant count
 * - Invalidates game cache to show updated participants
 *
 * Usage Example:
 *   ```tsx
 *   const GameRSVPButton = ({ gameId }) => {
 *     const rsvp = useRSVPToGame();
 *
 *     const handleRSVP = async () => {
 *       await rsvp.mutateAsync({
 *         game_id: gameId,
 *         status: 'attending'
 *       });
 *       Alert.alert('Success', 'You\'re in!');
 *     };
 *
 *     return (
 *       <Button
 *         onPress={handleRSVP}
 *         loading={rsvp.isPending}
 *       >
 *         Join Game
 *       </Button>
 *     );
 *   };
 *   ```
 *
 * @returns TanStack mutation hook
 */
export const useRSVPToGame = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (rsvpData: CreateRSVPInput) => {
      // ===================================================================
      // MOCK DATA MODE (Current)
      // ===================================================================

      await new Promise(resolve => setTimeout(resolve, 500));
      console.log('âœ… RSVP created (mock):', rsvpData.game_id);

      // ===================================================================
      // REAL SUPABASE MODE (Future - uncomment when ready)
      // ===================================================================

      /*
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Check if RSVP already exists
      const { data: existing } = await supabase
        .from('game_rsvps')
        .select('id')
        .eq('game_id', rsvpData.game_id)
        .eq('user_id', user.id)
        .single();

      if (existing) {
        // Update existing RSVP
        const { data, error } = await supabase
          .from('game_rsvps')
          .update({ status: rsvpData.status })
          .eq('id', existing.id)
          .select()
          .single();

        if (error) throw error;
        return data;
      } else {
        // Create new RSVP
        const { data, error } = await supabase
          .from('game_rsvps')
          .insert({
            game_id: rsvpData.game_id,
            user_id: user.id,
            status: rsvpData.status,
          })
          .select()
          .single();

        if (error) throw error;
        return data;
      }
      */
    },

    onSuccess: (_, variables) => {
      // Invalidate this game's data to show updated participant count
      queryClient.invalidateQueries({ queryKey: ['game', variables.game_id] });
      queryClient.invalidateQueries({ queryKey: ['games'] });
      console.log('âœ… Game cache invalidated after RSVP');
    },

    onError: (error: any) => {
      console.error('âŒ Failed to RSVP:', error);
    },
  });
};

/**
 * Cancel RSVP (decline/remove RSVP)
 *
 * Usage Example:
 *   ```tsx
 *   const CancelRSVPButton = ({ gameId }) => {
 *     const cancelRSVP = useCancelRSVP();
 *
 *     return (
 *       <Button
 *         onPress={() => cancelRSVP.mutate(gameId)}
 *         loading={cancelRSVP.isPending}
 *         variant="outline"
 *       >
 *         Cancel RSVP
 *       </Button>
 *     );
 *   };
 *   ```
 */
export const useCancelRSVP = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (gameId: string) => {
      // MOCK DATA MODE
      await new Promise(resolve => setTimeout(resolve, 500));
      console.log('âœ… RSVP cancelled (mock):', gameId);

      // REAL SUPABASE MODE (uncomment when ready)
      /*
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { error } = await supabase
        .from('game_rsvps')
        .delete()
        .eq('game_id', gameId)
        .eq('user_id', user.id);

      if (error) throw error;
      */
    },

    onSuccess: (_, gameId) => {
      queryClient.invalidateQueries({ queryKey: ['game', gameId] });
      queryClient.invalidateQueries({ queryKey: ['games'] });
    },
  });
};
